{"version":3,"sources":["components/CardList.js","components/SearchBox.js","components/Scroll.js","components/ErrorBoundry.js","containers/App.js","serviceWorker.js","index.js"],"names":["CardList","robots","Error","SearchBox","searchfield","searchChange","className","type","placeholder","onChange","Scroll","props","style","overflowY","border","height","children","ErrorBoundry","state","hasError","error","info","this","setState","Component","App","onSearchChange","event","target","value","fetch","then","response","json","users","filteredRobots","filter","robot","name","toLowerCase","includes","length","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","console","message"],"mappings":"oOA2BeA,EAxBE,SAAC,GAAc,EAAZC,OAElB,MAAM,IAAIC,MAAM,gBCWHC,EAdG,SAAC,GAAkC,EAAhCC,YAAiC,IAApBC,EAAmB,EAAnBA,aACjC,OACC,yBAAKC,UAAU,OACd,2BACCA,UAAU,mCACVC,KAAK,SACLC,YAAY,gBACZC,SAAUJ,MCECK,G,MATA,SAACC,GAEf,OACC,yBAAKC,MAAO,CAACC,UAAW,SAAUC,OAAQ,kBAAmBC,OAAQ,UACnEJ,EAAMK,YCmBKC,E,kDAtBd,WAAYN,GAAQ,IAAD,8BAClB,cAAMA,IACDO,MAAQ,CACZC,UAAU,GAHO,E,8DAODC,EAAOC,GACxBC,KAAKC,SAAS,CAAEJ,UAAU,M,+BAK1B,OAAIG,KAAKJ,MAAMC,SACP,uDAGDG,KAAKX,MAAMK,a,GAlBOQ,aCiDZC,E,kDA1Cd,aAAe,IAAD,8BACb,gBAcDC,eAAiB,SAACC,GACjB,EAAKJ,SAAS,CAAEnB,YAAauB,EAAMC,OAAOC,SAd1C,EAAKX,MAAQ,CACZjB,OAAQ,GACRG,YAAa,IAJD,E,gEASO,IAAD,OACnB0B,MAAM,8CACLC,MAAK,SAAAC,GAAQ,OAAGA,EAASC,UACzBF,MAAK,SAAAG,GAAQ,EAAKX,SAAS,CAAEtB,OAAQiC,S,+BAQ7B,IAAD,EACwBZ,KAAKJ,MAA7BjB,EADA,EACAA,OAAQG,EADR,EACQA,YACV+B,EAAiBlC,EAAOmC,QAAO,SAAAC,GACpC,OAAOA,EAAMC,KAAKC,cAAcC,SAASpC,EAAYmC,kBAEtD,OAAQtC,EAAOwC,OAGd,yBAAKnC,UAAU,MACd,wBAAIA,UAAU,MAAd,eACA,kBAAC,EAAD,CAAWD,aAAciB,KAAKI,iBAC9B,kBAAC,EAAD,KACC,kBAAC,EAAD,KACC,kBAAC,EAAD,CAAUzB,OAAQkC,OAPrB,2C,GA3BeX,aCIEkB,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,MCRNC,IAASC,OACL,kBAAC,EAAD,MACDC,SAASC,eAAe,SDuHrB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBtB,MAAK,SAAAuB,GACJA,EAAaC,gBAEdC,OAAM,SAAApC,GACLqC,QAAQrC,MAAMA,EAAMsC,a","file":"static/js/main.0b0ea040.chunk.js","sourcesContent":["import React from 'react';\r\nimport Card from './Card';\r\n\r\nconst CardList = ({ robots }) =>{\r\n\tif (true) {\r\n\t\tthrow new Error('NOOOOOOOOO!');\r\n\t}\r\n\r\n\treturn (\r\n\t\t<div>\r\n\t\t{\r\n \t\t\trobots.map((user, i)=>{\r\n\t\t\treturn (\r\n\t\t\t <Card\r\n\t\t\t \tkey={i} \r\n\t\t\t\tid={robots[i].id} \r\n\t\t\t\tname={robots[i].name} \r\n\t\t\t\temail={robots[i].email}\r\n\t\t\t\t/>\r\n\t\t\t\t);\r\n\t\t\t})\r\n \t\t}\r\n \t\t</div>\r\n\r\n\t\t);\r\n}\r\n\r\nexport default CardList;\r\n\r\n/*\r\n-map is used to return multiple components\r\n-receiving robots properties and destructing props right inside brackets-line -4\r\n-6th line states its passing id, name, email to Card.js\r\n-{robots} it is property, getting access to that file\r\n-with in robots when we map,,we get all elements one by one-we can say user \r\n-map should return\r\n-when we have a loop, we have to give it a unique key\r\n-div to div: its a jsx format\r\n-read the props that it recieves and it just renders something\r\n-robots are pure functions that they recieve something and return something,,props never change*/\r\n\r\n\r\n","import React from 'react';\r\n\r\nconst SearchBox = ({ searchfield, searchChange }) => {\r\n\treturn (\r\n\t\t<div className='pa2'>\r\n\t\t\t<input \r\n\t\t\t\tclassName='pa3 ba b--green bg-lightest-blue'\r\n\t\t\t\ttype='search' \r\n\t\t\t\tplaceholder='search robots' \r\n\t\t\t\tonChange={searchChange}\r\n\r\n\t\t\t/>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default SearchBox;\r\n\r\n\r\n/*\r\n-onChange: we are just listening to \"any ipnput changes\"\r\n*/","import React from 'react';\r\n\r\nconst Scroll = (props) =>{\r\n\t\r\n\treturn(\r\n\t\t<div style={{overflowY: 'scroll', border: '5px solid black', height: '800px'}}>\r\n\t\t\t{props.children}\r\n\t\t</div>\r\n\t\t);\r\n};\r\n\r\nexport default Scroll;","import React, { Component } from 'react';\r\n\r\nclass ErrorBoundry extends Component {\r\n\tconstructor(props) {\r\n\t\tsuper(props);\r\n\t\tthis.state = {\r\n\t\t\thasError: false\r\n\t\t}\r\n\t}\r\n\r\n\tcomponentDidCatch(error, info) {\r\n\t\tthis.setState({ hasError: true })\r\n\t}\r\n\r\n\r\n\trender() {\r\n\t\tif (this.state.hasError) {\r\n\t\t\treturn <h1>Ooops. That is not good</h1>\r\n\t\t}\r\n\r\n\t\treturn this.props.children\r\n\r\n\t}\r\n}\r\n\r\nexport default ErrorBoundry;\r\n\r\n/*\r\n- with react16 we are having new life cycle method that was introduced called componentDidCatch and its kind of try catch block in js\r\nif any thing errors out it will run this lifecycle hook and this get couple of parameters error and info\r\n\r\n-with this ErrorBoundry, if anything in the cardlist fails it's going to cach it and display our error message\r\n*/\r\n","import React, { Component } from 'react';\r\nimport CardList from '../components/CardList';\r\n//import { robots } from './robots';\r\nimport SearchBox from '../components/SearchBox';\r\nimport '../containers/App.css';\r\nimport Scroll from '../components/Scroll';\r\nimport ErrorBoundry from '../components/ErrorBoundry';\r\n\r\nclass App extends Component {\r\n\tconstructor() {\r\n\t\tsuper()\r\n\t\tthis.state = {\r\n\t\t\trobots: [],\r\n\t\t\tsearchfield: ''\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tcomponentDidMount() {\r\n\t\tfetch('https://jsonplaceholder.typicode.com/users')\r\n\t\t.then(response=> response.json())\r\n\t\t.then(users=>{this.setState({ robots: users })});\t\t\r\n\t}\r\n\r\n\tonSearchChange = (event) => { //everytime input changes with DOM we get an event\r\n\t\tthis.setState({ searchfield: event.target.value })\t\t\r\n\t}\r\n\r\n\r\n\trender() {\r\n\t\tconst { robots, searchfield } = this.state;\r\n\t\tconst filteredRobots = robots.filter(robot=>{\r\n\t\t\treturn robot.name.toLowerCase().includes(searchfield.toLowerCase());//comparing includes with robots.name\r\n\t\t})\r\n\t\treturn !robots.length?\r\n\t\t\t<h1>Loading</h1> :\r\n\t\t (\r\n\t\t\t<div className='tc'>\r\n\t\t\t\t<h1 className='f1'>RoboFriends</h1>\r\n\t\t\t\t<SearchBox searchChange={this.onSearchChange}/>\r\n\t\t\t\t<Scroll>\r\n\t\t\t\t\t<ErrorBoundry>\r\n\t\t\t\t\t\t<CardList robots={filteredRobots}/>\r\n\t\t\t\t\t</ErrorBoundry>\r\n\t\t\t\t</Scroll>\r\n\t\t\t</div>\r\n\t\t\t);\r\n\t\t\r\n\t}\r\n}\r\n\r\nexport default App;\r\n\r\n/*\r\n-Render props refers to a technique for sharing code between react components using a prop whose value is a function\r\n-we need SearchBox and carlist should communicate and also cahnge and update accordingly\r\n-state is an Object, an object that describes your application\r\n-state which describes our application is the robots, and whatever's entered in SearchBox\r\n-state is able to change value of SearchBox, the value of input we're able to change what robots get displayed\r\n-So parent feed 'state' into a child component and as soon as child component recieves a state\r\n-state is a property, that child naver change the property. the parent just tells it what the state\r\n-this state is something that can change and effect our app and they usually live in parent component,\r\n that pass state to different compnenets \r\n-CardList accept robots as props\r\n-app owns state that includes robots and it allowed to change\r\n-because of an object use this.\r\n//passed searchchange to searchbox*/","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';//core of package that does DOM manipulator\nimport ReactDOM from 'react-dom';\nimport './index.css'; //. represents its in the same directory\nimport App from './containers/App';\n\nimport * as serviceWorker from './serviceWorker';\nimport 'tachyons'; //now we are having access to tacayons\n\n\n\nReactDOM.render(\n\t\t\t\t<App />\n  ,document.getElementById('root')\n);\n\n\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}